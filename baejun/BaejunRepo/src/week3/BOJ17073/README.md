<h3 align="center"> 
    📢  [골드5] 백준(나무 위의 빗물) : https://www.acmicpc.net/problem/17073
</h3>

<br>

## 🚀 문제

트리란, 사이클이 없는 연결 그래프를 의미한다. 위 그림은 1번 정점을 루트로 하는 어떤 트리를 나타낸 모습이다.
사실 이 트리는 영훈이가 뒷마당에서 기르고 있는 나무이다. 어제는 비가 왔기 때문에, 트리의 1번 정점에는 W만큼의 물이 고여 있다. 1번 정점을 제외한 모든 정점에는 아직 물이 고여 있지 않은 상태이다.
이제 매초마다 모든 정점은 아래의 작업을 순서대로 반복한다.
- 물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다. 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다.
- 만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.
이때, 위 작업은 순서대로 진행되므로 부모 정점에게 받은 물을 즉시 자식 정점에게 줄 수는 없다.
영훈이는 나무를 바라보면서 더 이상 물이 움직이지 않는 상태가 되었을 때 각 정점에 어느 정도의 물이 있게 될지 궁금해졌다. 더 이상 물이 움직이지 않을 때, i번 정점에 쌓인 물의 양의 기댓값을 Pi라 하자. 이때, Pi가 0보다 큰 정점들에 대해서 Pi들의 평균은 어느 정도가 될까?

---

## 🚦입출력 + 제한사항

- 첫째 줄에 트리의 노드의 수 N과 1번 노드에 고인 물의 양을 의미하는 정수 W가 주어진다. (2 ≤ N ≤ 500,000, 1 ≤ W ≤ 109)
- 다음 N-1줄에 걸쳐, 트리에 존재하는 간선의 정보가 U V의 형태로 주어진다. (1 ≤ U, V ≤ N​​​​, U ≠ V)
- 이는 양 끝 정점이 각각 U와 V인 간선이 트리에 존재한다는 의미이다.
- 입력으로 주어지는 트리는 항상 올바른 연결 트리임이 보장되며, 주어지는 트리의 루트는 항상 1번 정점이다.
- 문제의 정답을 출력한다. 정답과의 차이가 10-3 이하인 값은 모두 정답으로 인정된다.

---

### 📜 문제 풀이(기능 목록, 접근법)
**🕸접근법**
- 처음엔 BFS별로 탐색하면서 트리 level별로 물이 고이는 양이 다른가? 싶었음
- 근데 테스트케이스 그냥 손으로 하나하나 다 따라가면서(물 양 20) 끝까지 해보니까 규칙이 바로보였음
- 이게 자식이 있는 노드가 물을 갖고있으면 무조건 자식에게 물을 줌. 이 말이 무슨 말이냐?
- leaf 노드, 즉 자식이 없는 노드들만 물을 모아둘수 있단 소리임, 자식이 있는 노드들은 그 작업을 못할 때까지(0이될때까지) 계속 자식한테 물을 줘야되니까
- 근데 문제에서 구하라는 기댓값에, 0인 애들의 수는 제외한다고 했음, 이게 무슨 말이냐? leaf 노드(물이 있는 노드) 개수만 구하면 된다 이 말이야~
- 그래서 W / leafNodeCount (물의 총 양 / 리프노드 수)

### 💻코드

```java
int count = 0;
/* leaf노드 개수 세기(1번노드는 무조건 root노드라 문제에 명시 돼 있어서 생략) */
for(int i = 2; i <= N; i++) {
	if(trees[i].list.size() == 1) count++;
}
System.out.printf("%.3f", W / count); // 물의 총 양에서 리프노드 수 나눠주기 -> 기댓값이 0 이상인 애들만 집계한다했음, 자식노드가 있으면 무조건 기댓값은 0임.
```

### 🙄 후기
소요시간 : 30분  <br>
예외처리 몇개를 놓쳐 30분이지, 문제 읽고 테케 직접 해보고 바로 아이디어를 떠올린 아주 기특한 문제다. <br>
사실 처음 문제를 읽고, 이게 뭔 개소린지 싶어서 그냥 문제 이해하려고 테케를 직접 손으로 하나하나 다 그려봤는데, 테케를 그려보자말자 규칙이 너무 쉽게 보였다. <br>
역시 코드 짜기전에 문제를 완벽히 이해하고 접근하는게 알고리즘의 첫 단계라는걸 또 깨닫게 해주는 문제가 아닌가 싶다
<h3 align="center"> 
    📢  [골드5] 백준(부분 삼각 수열) : https://www.acmicpc.net/problem/1548
</h3>

<br>

## 🚀 문제

세 수 x, y, z가 x+y>z, x+z>y, y+z>x의 관계를 만족하면, 세 수는 삼각관계에 있다고 한다.
마찬가지로 길이가 N인 수열 B(b[0], b[1], ..., b[n-1])의 모든 b[i], b[j], b[k]가 삼각관계에 있으면 이 수열은 삼각 수열이라고 한다. 이때, i, j, k는 모두 다른 값이다.
수열 A가 주어졌을 때, 이 수열에서 적절히 몇 개의 원소를 빼서 이 수열을 삼각 수열로 만들려고 한다. 삼각 수열의 최대 길이를 구하는 프로그램을 작성하시오.

---

## 🚦입출력 + 제한사항

- 첫째 줄에 수열의 크기 N이 주어진다. 둘째 줄에 수열 A에 들어있는 수가 공백을 사이에 두고 주어진다. N은 최대 50이고, A에 들어있는 수는 109보다 작거나 같은 자연수이다.
- 첫째 줄에 가장 긴 부분 삼각 수열의 길이를 출력한다.

---

### 📜 문제 풀이(기능 목록, 접근법)
**🕸접근법**
- 처음에 문제 읽고, 뭔 소리 하는건지 이해가 안됐음
- 한 10분정도 읽고, 문제가 뭔 말하는건지 이해하고 보니, 규칙을 발견함
- 작은 두 수의 합 > 수열의 최대값 일때만 삼각수열이 만족된다는 규칙이 있음
- 원본 배열을 유지할 필요가 없기때문에, 정렬을 시켜놓고 완전탐색을 하며 포인터 하나 생성
- 배열 idx와 idx+1 의 값을 pointer 값과 비교하며 pointer를 증가시키며 길이의 최대값 구함

- [x] 투포인터 사용

### 💻코드

```java
/* 처리로직 */
Arrays.sort(sequence); // 배열 정렬
int maxLength = 0;
for(int i = 0; i < N; i++) {
	int currentLength = 0;
	int pointer = i + 2;
	while(pointer < N) {
		// 삼각 수열 만족한다면 범위 확장, 아니라면 쫑
		if(sequence[i] + sequence[i+1] > sequence[pointer]) {
			currentLength++;
			pointer++;
		} else {
			break;
		}
	}
	if(maxLength < currentLength) maxLength = currentLength;
}
```

### 🙄 후기
소요시간 : 30분  <br>

직전에 다르지만 비슷한 늬앙스의 문제를 풀어서 그런가 아이디어를 금방 떠올려냈다. <br>
역시 이런식으로 경험을 늘려나가고 다양한 케이스를 마주하면서 아이디어를 떠올리는 속도를 단축 시킬 수 있는 것 같다. <br>

그리고 pointer가 조건을 불만족하면, 앞의 포인터를(반복문 돌고 있는 인덱스) pointer 직전인덱스까지 땡겨도 가능할거라 생각했다(앞의 pointer부터 지금 pointer까진 그게 최대값이라 생각해서) <br>
근데 앞 포인터가 두 인덱스의 합으로 움직이다 보니, 이 부분에선 반례가 발생하더라, 운좋게 시작부터 완탐을 생각해서 바로 맞췄지, 아니였다면 꽤나 헤맸을듯? <br>
싸피 수업때 처럼 완탐으로 시간이 충분하다면, 완탐으로 조지는 것도 결코 나쁜게 아닌거 같다. 일단 시간 안에 들어와진다면, 정확성을 가장 잘 보장해주니까
<h3 align="center"> 
    📢  [레벨3] 프로그래머스(합승 택시 요금) : https://school.programmers.co.kr/learn/courses/30/lessons/72413
</h3>

<br>

## 🚀 문제

---

## 🚦입출력 + 제한사항

- 지점갯수 n은 3 이상 200 이하인 자연수입니다.
- 지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.
- 즉, 출발지점, A의 도착지점, B의 도착지점은 서로 겹치지 않습니다.
- fares는 2차원 정수 배열입니다.
- fares 배열의 크기는 2 이상 n x (n-1) / 2 이하입니다.
- 예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (6 x 5 / 2 = 15)
- fares 배열의 각 행은 [c, d, f] 형태입니다.
- c지점과 d지점 사이의 예상 택시요금이 f원이라는 뜻입니다.
- 지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.
- 요금 f는 1 이상 100,000 이하인 자연수입니다.
- fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다.
- 출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다.

---

### 📜 문제 풀이(기능 목록, 접근법)
**🕸접근법**
- 흠.. 바로 플로이드 워셜을 못 떠올리긴했음, 그래서 그냥 플로이드 워셜인거 보고 품
- 그리고 합승을 기준으로 최소값 찾음, 합승을 해서 어디서 내리는지를 기준으로

- [x] 플로이드 워셜을 이용하여 모든 노드에서 노드 간 거리 구하기

### 💻코드

```java
for(int i = 1; i < n+1; i++) {
	for(int j = 1; j < n+1; j++) {
		for(int k = 1; k < n+1; k++) {
        	dist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);
        }
    }
}

for(int i = 1; i < n+1; i++) {
	for(int j = 1; j < n+1; j++) {
		if(answer > dist[s][i] + dist[i][a] + dist[i][b]) answer = dist[s][i] + dist[i][a] + dist[i][b];
	}
}

```

### 🙄 후기
소요시간 : 1시간 30분?  <br>
은근 직관적이다 생각했는데, 문제보고 떠올리기가 쉽지 않을지도 ..? 
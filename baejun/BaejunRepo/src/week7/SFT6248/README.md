<h3 align="center"> 
    📢  [레벨3] 소프티어(출퇴근길) : https://softeer.ai/practice/6248
</h3>

<br>

## 🚀 문제

자동차로 출퇴근을 하는 동환이는 지루하지 않게 종종 길을 바꿔 다니곤 한다. 새로운 동네를 발견하는 일은 동환이의 소소한 행복이다.
동환이의 출근길과 퇴근길은 가끔 겹친다. 즉, 출근길에 들른 동네를 퇴근길에 다시 지나곤 하는 것이다. 이에 대해 곰곰이 생각하던 동환이는 이렇게 두 번 들를 수 있는 동네가 그렇게 많지 않음을 깨달았다. 도로의 연결 모양, 그리고 일방통행 여부 등으로 인해 출퇴근길 모두 방문 가능한 동네가 한정되는 것이다.
동환이의 출퇴근길은 단방향 그래프로 나타낼 수 있다. 즉, 각 동네를 1부터 n까지의 번호가 매겨진 n개의 정점으로, m개의 일방통행의 도로를 단방향 간선으로 삼아 그래프를 만들 수 있다. 이때 동환이의 집과 회사가 각각 정점 S와 T로 나타난다고 하면 출퇴근길은 S와 T 사이의 경로로 나타난다.
동환이의 출퇴근길을 본딴 그래프가 주어지면 S에서 T로 가는 출근길 경로와 T에서 S로 가는 퇴근길 경로에 모두 포함될 수 있는 정점의 개수를 세는 프로그램을 작성하시오.
단, 출퇴근길에서 목적지 정점을 방문하고 나면 동환이는 더 이상 움직이지 않는다. 즉, 출근길 경로에 T는 마지막에 정확히 한 번만 등장하며, 퇴근길 경로도 마찬가지로 S는 마지막에 한 번만 등장해야 한다. (출근길 경로에 S는 여러 번 등장해도 되고, 퇴근길 경로에 T는 여러 번 등장해도 된다.)
---

## 🚦입출력 + 제한사항

* 5 ≤ n ≤ 100,000
* 5 ≤ m ≤ 200,000
* 1 ≤ S ≤ n이고 1 ≤ T ≤ n이며 S ≠ T
* S에서 T로 가는 경로와 T에서 S로 가는 경로가 하나 이상 존재함이 보장된다.
* 간선의 양 끝 점은 서로 다르다.
* 같은 정점쌍을 같은 방향으로 잇는 간선은 두 개 이상 주어지지 않는다.

---

### 📜 문제 풀이(기능 목록, 접근법)
**🕸접근법**
- DFS로 모든 경우 탐색하는데, 총 4번 돌림
- 출근길, 퇴근길 한번씩, 그리고 정방향, 역방향 한번씩

- [x] dfs를 이용하여 탐색

### 💻코드

```java
// 출,퇴근길은 한번씩만 방문, visited3, 4를 통해 해당 노드에서 도착점으로 갈수있는지 체크
visited1[endV] = true;
DFS1(startV, visited1);
visited2[startV] = true;
DFS1(endV, visited2);
DFS2(startV, visited3);
DFS2(endV, visited4);
int cnt = 0;

// 정방향
private static void DFS1(int node, boolean visited[]) {
	//기저조건
	if(visited[node]) {
		return;
	}
	visited[node] = true;
	//유도조건
	for(int i = 0; i < list.get(node).size(); i++) {
		DFS1(list.get(node).get(i), visited);
	}
}

// 역방향
private static void DFS2(int node, boolean visited[]) {
	//기저조건
	if(visited[node]) {
		return;
	}
	visited[node] = true;
	//유도조건
	for(int i = 0; i < list2.get(node).size(); i++) {
		DFS2(list2.get(node).get(i), visited);
	}
}
```

### 🙄 후기
소요시간 : 2시간  <br>
모르겠었어서 그냥 질문들 보고 어느정도 접근법 감 잡고 품<br>
소프티어 쉽지않을듯..?
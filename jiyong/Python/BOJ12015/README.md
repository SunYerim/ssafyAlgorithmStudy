[백준][G2] 12015 가장 긴 증가하는 부분 수열 2 / (AC)
---
> **문제 설명**
>

[[문제 링크](https://www.acmicpc.net/problem/12015)]

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 <span>$A = {10, 20, 10, 30, 20, 50}$</span> 인 경우에 가장 긴 증가하는 부분 수열은 <span>$A = {10, 20, 10, 30, 20, 50}$</span>
이고, 길이는 `4`이다.

---

> **제한사항**
>

**입력**

첫째 줄에 수열 `A`의 크기 `N` (`1` ≤ `N` ≤ `1,000,000`)이 주어진다.

둘째 줄에는 수열 `A`를 이루고 있는 `<span>$A_i$</span>`가 주어진다. (`1` ≤ <span>$A_i$</span> ≤ `1,000,000`)

**출력**

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

---

> **문제 풀이**

**최장 증가 부분 수열**(Longest Increasing Subsequence) 문제는 크게 두 가지 해법이 있는데, `다이나믹 프로그래밍`을 활용하여 해결하는 방법과, `이진 탐색`을 활용하여 해결하는 방법이 있다. 결론부터 얘기하자면, `다이나믹 프로그래밍`을 활용하는 방법은 시간복잡도가 `O(n^2)`이 소요 되는데, 해당 문제의 입력이 최대 `1,000,000`까지 입력 되므로 `TLE`를 면할 수 없다.  

- `이진 탐색`을 활용하여 `LIS`를 구하는 방법
1. 부분 수열을 담을 배열을 선언하여, 수열 `A`의 첫 번째 원소를 0번 인덱스에 추가하여 초기화한다. 
2. 수열 `A`의 두 번째 원소부터 순회하며 다음 규칙에 따라 부분 수열을 업데이트 한다.
    1. `A의 현재 원소` > `부분 수열의 마지막 원소`인 경우 부분 수열의 마지막에 원소를 추가한다.
    2. `A의 현재 원소` < `부분 수열의 마지막 원소`인 경우 `이진 탐색`을 통해 `부분 수열`에서 <span>$A_(i-1)$</span> < `A의 현재 원소` ≤ <span>$A_i$</span>인 `i`를 찾아 해당 인덱스에 원소를 삽입한다.
    3. `A의 현재 원소` = `부분 수열의 마지막 원소`인 경우는 생략한다.
3. 2번의 과정 중 최대가 되는 수열의 길이를 리턴한다.

위의 과정에서 ii번 조건의 경우는 해당 원소가 마지막 원소가 되는 부분 수열의 길이를 찾는 과정이다. 따라서 위의 알고리즘은 `최장 증가 부분 수열`의 `길이`만을 알고 싶을 경우에만 사용할 수 있다. 만약, `최장 증가 부분 수열`을 구하고자 한다면 구조를 많이 변경하여 중간중간 후보가 되는 수열을 저장하고, 원소를 삽입할 때 삽입하지 않은 배열도 저장하여 유지 해두어야  한다. 


---

> **코드**
>

```python
import sys

input = sys.stdin.readline

N = int(input())

seq = list(map(int, input().split()))
lis = [0] * N
lis[0] = seq[0]
length = 0
answer = 1


def bi_search(n: int, target: int):
    lp, rp = 0, n
    mid = (lp + rp) // 2
    while lp < rp:
        if lis[mid] == target:
            return mid
        elif lis[mid - 1] < target < lis[mid]:
            return mid
        elif lis[mid] < target:
            lp = mid + 1
        else:
            rp = mid - 1
        mid = (lp + rp) // 2
    return lp


for i in range(1, N):
    if lis[length] >= seq[i]:
        lis[bi_search(length, seq[i])] = seq[i]
    else:
        length += 1
        lis[length] = seq[i]
    answer = max(answer, length + 1)

print(answer)
```

---

> **후기**

해당 문제는 정확히는 `이진 탐색`알고리즘 중의 하나인 `파라메트릭 서치(매개변수 탐색)`으로 분류되는 것이 마땅한 것 같다. 

문제 풀이 시간 : 30분 / 실행시간 : `548ms` / 메모리 : `228020KB` / 코드길이 : `730B`

알고리즘 분류 : 이진 탐색, 최장 증가 부분 수열

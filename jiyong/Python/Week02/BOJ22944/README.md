
[백준][G3] 22944 죽음의 비 / (AC)
---
> **문제 설명**


[[문제 링크](https://www.acmicpc.net/problem/22944)]

가로, 세로 길이가 
$N$인 정사각형 격자가 있다. 해당 격자에는 두 곳을 제외한 모든 곳에 체력을 1씩 감소시키는 죽음의 비가 내리고 있다. 죽음의 비가 안내리는 곳은 현재 있는 위치와 안전지대라는 곳이다. 현재 있는 위치에도 곧 비가 내릴 예정이라 빨리 이 죽음의 비를 뚫고 안전지대로 이동해야한다.

다행히도 격자에는 죽음의 비를 잠시 막아주는 우산이 
$K$개 존재한다. 우산에는 내구도 
$D$라는 개념이 존재한다. 우산에 비를 맞으면 내구도가 1씩 감소하고, 내구도가 0이 되는 순간 우산은 사라진다. 문제에서 주어지는 우산의 내구도는 모두 
$D$로 동일하다.

격자에서 이동을 할 때 다음과 같이 순서로 진행된다.

1. 상하좌우로 이동한다. 만약 이동할 곳이 격자 밖이라면 이동할 수 없다. 
2. 이동한 곳이 안전지대라면 반복을 종료한다.
3. 이동한 곳에 우산이 있다면 우산을 든다. 만약, 이동할 때부터 우산을 가지고 있다면 가지고 있는 우산을 버리고 새로운 우산으로 바꾼다. 버린 우산은 더 이상 사용할 수 없다.
4. 죽음의 비를 맞았을 때, 우산을 가지고 있다면 우산의 내구도가 1이 감소하고 만약 우산을 가지고 있지 않는다면 체력이 1 감소한다.
5. 만약 우산의 내구도가 0이 되면 들고 있는 우산이 사라진다.
6. 만약 체력이 0이 되면 죽는다...
7. 아직 체력이 남았다면 안전지대까지 위 과정을 반복한다.

현재 있는 위치에서 안전지대로 얼마나 빠르게 이동할 수 있는지 구해주자.

---

> **제한사항**
> 

**입력**

첫 번째 줄에 정사각형 격자의 한변의 길이인 
$N$와 현재 체력 
$H$, 우산의 내구도 
$D$가 공백으로 구분되어 주어진다.

다음 
$N$개의 줄에는 정사각형 격자의 정보가 
$N$개의 문자로 붙어서 주어진다. 이때 주어지는 문자는 우산은 "U", 현재 있는 위치 "S", 안전지대 "E", 빈 칸 "."만 존재한다. 현재 있는 위치 "S"와 안전지대 "E"는 반드시 1개 존재한다.

**출력**

안전지대로 이동할 때 최소 이동 횟수를 출력한다. 만약 안전지대로 이동하지 못하는 경우에는 -1을 출력한다.

---

> **문제 풀이**

최단 거리를 묻는 문제라서 `너비 우선 탐색`을 생각 하였는데, 일반적인 구현•시뮬레이션 문제와는 조금 다르게 경로 상의 방해물은 존재하지 않기 때문에 만약 체력만 있다면, 선형 계산만으로 시간을 구할 수 있다. 

`현재 위치` ~ `도착 지점` 간의 맨해튼 거리(Manhattan Distance)를 구하여 `현재 체력` + `우산의 내구도` 보다 작거나 같으면 도착할 수 있으므로 `현재 시간` + `거리`를 리턴하고, 크다면 갈 수 있는 `우산 지점`으로 가서 위의 과정을 반복하면 된다.
가용한 `우산 지점`은 여러 곳일 수 있으므로, 각 `우산 지점`으로 가는 경우를 `백트래킹`을 통해 분기를 나누고, 이 분기들을 `너비 우선 탐색`하며 최단 거리를 구하는 전략을 사용하였다. 

1. `시작 지점`, `도착 지점`, `우산 지점`을 각각 맵에서 찾아 저장한다(우산의 경우 다수개가 가능하므로 리스트 사용).
2. `우산 지점`을 담은 리스트를 (`우산` ~ `현재 위치(초기값은 시작 지점)`간의 거리 + `우산` ~ `도착 지점`간의 거리)를 기준으로 오름차순 정렬한다.
3. `큐`에 초기값 (`현재 위치`, `체력`, `우산 내구도`, `현재 시간`, `우산 지점`)을 넣고 `너비 우선 탐색`을 시작한다.
    1. `현재 위치`~`도착 지점` 간의 거리가 `체력`+`우산 내구도`가 작거나 같은지 판별한다.
        1. `True` : `현재 시간` + `거리`를 리턴
    2. 만약 크다면, `현재 위치` ~ `우산 지점`까지 거리가 `체력`+`우산 내구도`보다 작거나 같은 `우산 지점`을 찾아 해당 `우산 지점`을 제외하고, 2번 과정으로 재정렬된 리스트를 만들어 `큐`에 삽입한다.
    3. 도착하거나 더 이상 갈 수 있는 지점이 없을 때까지 위 과정을 반복한다.
    

---

> **코드**
> 

```python
import sys
from collections import deque

input = sys.stdin.readline
N, H, D = map(int, input().split())
map_ = [[*input().rstrip()] for _ in range(N)]
dq = deque()
umbrella = []
answer = -1


def distance(r1, c1, r2, c2):
    return abs(r1 - r2) + abs(c1 - c2)


for r in range(N):
    for c in range(N):
        if map_[r][c] == 'S':
            S = (r, c)
        elif map_[r][c] == 'E':
            E = (r, c)
        elif map_[r][c] == 'U':
            umbrella.append((r, c))


umbrella.sort(key=lambda x: distance(*x, *S) + distance(*x, *E))

dq.append((*S, H, 0, 0, umbrella))

while dq:
    r, c, h, u, t, u_list = dq.popleft()
    dist = distance(r, c, *E)
    if dist <= h + u:
        answer = t + dist
        break
    for um in u_list:
        if (dist := distance(r, c, *um)) <= h + u:
            if u >= dist:
                dq.append((*um, h, D, t + dist, sorted([x for x in u_list if x != um], key=lambda x: distance(*x, *um) + distance(*x, *E))))
            else:
                dq.append((*um, h + u - dist, D, t + dist, sorted([x for x in u_list if x != um], key=lambda x: distance(*x, *um) + distance(*x, *E))))

print(answer)
```

---

> **후기**

구현부에서 `현재 위치` ~ `도착 지점`의 맨해튼 최단 경로 내의 `우산`을 먼저 고려해야 한다는 점을 놓쳐서 처음에는 WA가 나왔었다... 그래도 금방 반례를 찾아 크게 헤매지는 않았던 문제.


문제 풀이 시간 : 1시간 / 실행시간 : `164ms` / 메모리 : `118428KB` / 코드길이 : `1153B`

알고리즘 분류 : BFS, 백트래킹, 브루트포스
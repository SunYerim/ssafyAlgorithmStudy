
[백준][G1] 1016 제곱 ㄴㄴ 수 / (AC)
---
> **문제 설명**


[[문제 링크](https://www.acmicpc.net/problem/1016)]

어떤 정수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 그 수를 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min보다 크거나 같고, max보다 작거나 같은 제곱ㄴㄴ수가 몇 개 있는지 출력한다.

---

> **제한사항**


**입력**

첫째 줄에 두 정수 min과 max가 주어진다.
- 1 ≤ min ≤ 1,000,000,000,000
- min ≤ max ≤ min + 1,000,000


**출력** 

첫째 줄에 min보다 크거나 같고, max보다 작거나 같은 제곱ㄴㄴ수의 개수를 출력한다.

---

> **문제 풀이**

입력 제한 조건을 보면 `min`값이 1조까지 들어오는데, 다행스럽게도 `max`값은 `min`보다 최대 1,000,000까지 큰 값이라서 `O(max - min)`안에 해결할 로직을 작성하면 된다.

문제를 조금만 다르게 생각하면, 특정 구간 내의 소수를 판별하는 것과 유사하다는걸 알 수 있다. 즉, `에라토스테네스의 체`를 조금 바꿔서 구현하면 된다.

`에라토스테네스의 체`는 특정 구간 내의 소수를 빠르게 판별하는 방법으로, 논리는 다음을 따른다.
1. 구간 만큼 크기의 `배열`을 생성하고, `1`로 초기화한다.
2. 먼저 `0`, `1`번 `인덱스`의 값을 `0`으로 바꾼다.
3. `2`부터 구간의 끝 값 사이의 소수들을 순회하며, 각 소수의 `n`배수(`n>1`)번 인덱스의 값을 `0`으로 바꾼다.
4. 끝까지 순회한 뒤 바뀌어진 `배열` 중, 값이 `1`인 상태인 `인덱스`는 **소수**가 된다.

위의 로직을 조금만 바꾼다면 `제곱 ㄴㄴ 수`를 찾을 수 있다. 다만, `제곱 ㄴㄴ 수`를 찾는 구간이 최대 `long`타입에서 정의될 수 있으므로, 찾고자 하는 구간이 아닌 구간(min보다 작은)은 배열로 굳이 생성할 필요가 없다. min보다 작은 구간은 추상적으로 있다고 가정하고, `배열`의 시작 인덱스를 0이 아닌 min이라고 생각하고 구현하면 된다.
1. `max-min+1`크기(최대 1,000,001)의 `에라토스테네스의 체` `배열`을 생성하고 1로 초기화한다.
2. `1 < 제곱 수 <=max`인 `제곱 수`를 순회하며, `min <= 제곱 수 * n(n>0) <= max` 을 만족하는 `n`에 대하여 거듭 순회한다.
3. 순회하면서 1번에서 생성한 `배열`을 수정한다(이때, 인덱스 번호는 추상적으로 `min`부터니까 실제로는 `idx-min`값으로 인덱싱).

---

> **코드**
 

```python
import sys, math

N, M = map(int, sys.stdin.readline().split())

eratos = [1] * (M - N + 1)
answer = (M - N + 1)
i = 2

while (sqr := i ** 2) <= M:
    for j in range(sqr * math.ceil(N / sqr), M + 1, sqr):
        if j >= N and eratos[j - N] == 1:
            eratos[j - N] = 0
            answer -= 1
    i += 1

print(answer)
```

---

> **후기**
 
문제를 푼 시간보다 풀이를 작성하는게 더 오래 걸린 문제다. 제한 사항을 보고 빠르게 에라토스테네스의 체를 활용해야 한다는 아이디어를 생각해내면 어렵지 않게 풀 수 있었던 문제.  <del>(물 골드1)</del>


문제 풀이 시간 : 15~30분 / 실행시간 : `160ms` / 메모리 : `118408KB` / 코드길이 : `325B`

알고리즘 분류 : 정수론, 에라토스테네스의 체, 소수 판정, 수학
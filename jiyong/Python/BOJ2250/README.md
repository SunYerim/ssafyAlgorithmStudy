
[백준][G2] 2250 트리의 높이와 너비 / (AC)
---
> **문제 설명**
> 

[[문제 링크](https://www.acmicpc.net/problem/2250)]

이진트리를 다음의 규칙에 따라 행과 열에 번호가 붙어있는 격자 모양의 틀 속에 그리려고 한다. 이때 다음의 규칙에 따라 그리려고 한다.

이진트리에서 같은 레벨(level)에 있는 노드는 같은 행에 위치한다.
한 열에는 한 노드만 존재한다.
임의의 노드의 왼쪽 부트리(left subtree)에 있는 노드들은 해당 노드보다 왼쪽의 열에 위치하고, 오른쪽 부트리(right subtree)에 있는 노드들은 해당 노드보다 오른쪽의 열에 위치한다.
노드가 배치된 가장 왼쪽 열과 오른쪽 열 사이엔 아무 노드도 없이 비어있는 열은 없다.
이와 같은 규칙에 따라 이진트리를 그릴 때 각 레벨의 너비는 그 레벨에 할당된 노드 중 가장 오른쪽에 위치한 노드의 열 번호에서 가장 왼쪽에 위치한 노드의 열 번호를 뺀 값 더하기 1로 정의한다. 트리의 레벨은 가장 위쪽에 있는 루트 노드가 1이고 아래로 1씩 증가한다.

아래 그림은 어떤 이진트리를 위의 규칙에 따라 그려 본 것이다. 첫 번째 레벨의 너비는 1, 두 번째 레벨의 너비는 13, 3번째, 4번째 레벨의 너비는 각각 18이고, 5번째 레벨의 너비는 13이며, 그리고 6번째 레벨의 너비는 12이다.

<div align="center">
<img src="https://upload.acmicpc.net/4e4aaa17-dc1d-4af9-a36a-3144259fb7d2/-/preview/" height="180px">
</div>


우리는 주어진 이진트리를 위의 규칙에 따라 그릴 때에 너비가 가장 넓은 레벨과 그 레벨의 너비를 계산하려고 한다. 위의 그림의 예에서 너비가 가장 넓은 레벨은 3번째와 4번째로 그 너비는 18이다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때는 번호가 작은 레벨을 답으로 한다. 그러므로 이 예에 대한 답은 레벨은 3이고, 너비는 18이다.

임의의 이진트리가 입력으로 주어질 때 너비가 가장 넓은 레벨과 그 레벨의 너비를 출력하는 프로그램을 작성하시오


---

> **제한사항**

**입력**

첫째 줄에 노드의 개수를 나타내는 정수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 각 줄마다 노드 번호와 해당 노드의 왼쪽 자식 노드와 오른쪽 자식 노드의 번호가 순서대로 주어진다. 노드들의 번호는 1부터 N까지이며, 자식이 없는 경우에는 자식 노드의 번호에 -1이 주어진다.

**출력**

첫째 줄에 너비가 가장 넓은 레벨과 그 레벨의 너비를 순서대로 출력한다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때에는 번호가 작은 레벨을 출력한다.



---

> **문제 풀이**

`이진트리`를 격자 모양에 그리는 규칙을 유심히 보면, `왼쪽 서브트리` - `루트 노드` - `오른쪽 서브트리`순으로 열 번호를 매기는데, 이는 `중위 순회`의 순회 순서와 같다.

이 규칙성을 따라 `이진트리`를 `깊이 우선 탐색`을 하며, `깊이`별 `노드`의 `너비`를 자료구조에 저장하고, 이 중 최대가 되는 `너비`와 `깊이`를 찾으면 된다.



---

> **코드**
> 

```python
import sys

input = sys.stdin.readline
N = int(input())
tree = [[] for _ in range(N + 1)]
idx = 1
dw = [[] for _ in range(N + 1)]
find_root = [False] * (N + 2)

for _ in range(N):
    root, left, right = map(int, input().split())
    tree[root] = [left, right]
    find_root[left] = True
    find_root[right] = True

find_root[0] = True
root = find_root.index(False)


def dfs(root, depth):
    global idx
    left, right = tree[root]
    if left != -1:
        dfs(left, depth + 1)
    dw[depth].append(idx)
    idx += 1
    if right != -1:
        dfs(right, depth + 1)


dfs(root, 1)

max_width = 0
max_depth = 0
for idx, nodes in enumerate(dw):
    if not nodes:
        continue
    elif nodes[-1] - nodes[0] + 1 > max_width:
        max_width = nodes[-1] - nodes[0] + 1
        max_depth = idx

print(max_depth, max_width)
```

---

> **후기**

해법과 구현은 30분도 체 걸리지 않았는데, 문제를 잘못 읽어서 `루트 노드`가 무조건 1인 경우만 살피다가 꽤나 헤맸던 문제. <del>문제 좀 제대로 읽자</del>   

문제 풀이 시간 : 1시간 / 실행시간 : `184ms` / 메모리 : `114916KB` / 코드길이 : `851B`

알고리즘 분류 : 트리, 깊이 우선 탐색, 그래프 이론/탐색

[백준][G3] 12945 재미있는 박스 정리 / (AC)
---
> **문제 설명**
> 

[[문제 링크](https://www.acmicpc.net/problem/12945)]

민호는 N개의 박스를 가지고 있다. 어느 날 박스가 너무 많아져 박스를 정리하고 싶어졌다. 하지만 평범한 박스정리가 너무 지루하다고 생각한 민호는 재미를 위해 몇 가지 규칙을 정하고 박스를 정리하기로 생각했다. 규칙은 아래와 같다.

1. 박스 x의 크기를 V[x], 박스 y의 크기를 V[y]라 할 때 V[y]는 적어도 V[x]의 두배는 되어야지 x를 y에 넣을 수 있다.
2. 박스 x를 박스 y에 넣었다면 y는 다른 박스에 넣지 못한다. 한 박스안에 들어있는 모든 박스는 많아야 한 개이다.

위와 같은 규칙을 지켜 박스 정리를 할 때 최적의 경우를 구해보자. 최적의 경우라 하면 눈에 보이는 박스의 개수가 최소가 되는 경우를 의미한다.

---

> **제한사항**


**입력**

첫째 줄에 민호가 가지고 있는 박스의 개수 N (1 ≤ N ≤ 500,000) 이 주어진다.

두번 째 줄부터 N개의 줄에 걸쳐 민호가 가지고 있는 박스들의 크기 V (1 ≤ V ≤ 100,000) 이 주어진다.


**출력** 

규칙을 지켜가며 박스 정리를 했을 때 최적의 경우를 출력한다.

---

> **문제 풀이**

최적의 경우를 구하는 문제이기에 그리디 전략으로 먼저 접근.

1. 입력 받은 데이터를 오름차순으로 정렬한다.
2. `0`번 인덱스와 `N//2`인덱스로부터 투포인터 탐색을 한다.
3. `boxes[l] * 2 <= boxes[r]`인 경우, 박스를 포갠다.

###
**유의사항**
1. 한 번 포갠 박스는 더 이상 포갤 수 없다.
2. 가능한 최적의 경우는 N / 2 개로 포갠 경우이다.
3. **박스 A에 넣는 박스 B의 크기는 A 박스 크기의 1/2에 인접한다고 최적이 되는 것은 아니다.**

3번 항목이 가장 중요한 포인트였는데, 2번 항목과 복합적으로 생각해보면 절반 지점을 기점으로 나누어 왼쪽 그룹과 오른쪽 그룹을 각각 비교하여야 한다.

---

> **코드**
 

```python
import sys
N = int(sys.stdin.readline())

boxes = [int(sys.stdin.readline()) for _ in range(N)]
boxes.sort()

l, r = 0, N // 2
count = N

while l < N // 2 and r < N:
    if boxes[r] >= boxes[l] * 2:
        count -= 1
        l += 1
    r += 1
print(count)
```

---

> **후기**
> 

`input()` 함수를 이용하여 입력을 받았을 때, I/O 오버헤드가 너무 많이 발생하여 TLE가 났었다.. 투포인터 탐색이 무한루프에 빠지진 않는지 한참을 헤맸지만, 결국 `sys` 모듈의 표준 입력을 사용하니 해결됐던 문제. 프로그래머스에 너무 익숙했나 보다...

문제 풀이 시간 : 1시간 / 실행시간 : `444ms` / 메모리 : `53480KB` / 코드길이 : `256B`

알고리즘 분류 : 그리디
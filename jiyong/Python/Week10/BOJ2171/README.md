[백준][G5] 2171 직사각형의 개수 / (AC)
---
> **문제 설명**
>

[[문제 링크](https://www.acmicpc.net/problem/2171)]

2차원 평면 위에 N(1 ≤ N ≤ 5,000)개의 점들이 있다. 이런 점들 중 서로 다른 네 개의 점을 잡아서 연결하면 사각형이 만들어진다. 이러한 사각형들 중에서, x축과 y축에 평행한 직사각형의 개수를 구하는 프로그램을 작성하시오. 직사각형의 넓이는 양수이어야 한다.

---

> **제한사항**
>

**입력**

첫째 줄에 N이 주어진다. 다음 `N`개의 줄에는 각 점의 `x`, `y`좌표가 주어진다. 좌표의 범위는 `-1,000,000,000` 이상 `1,000,000,000` 이하이며, 두 점의 좌표가 같은 경우는 없다.

**출력**

첫째 줄에 직사각형의 개수를 출력한다.

---

> **문제 풀이**

`x 좌표`를 키로 가지는 `int`:`set` 제네릭의 `해시 맵` 자료구조를 만들어 `y 좌표`를 `set`에 담고, 임의의 두 `x 좌표`에 대응되는 `set`간의 교집합(`&`)을 통해 직사각형을 만들 수 있는 점의 조합을 찾는다.

---

> **코드**
>

```python
import sys
from collections import defaultdict

input = sys.stdin.readline

N = int(input())
dic = defaultdict(set)
answer = 0

for _ in range(N):
    x, y = map(int, input().split())
    dic[x].add(y)

set_list = list(dic.values())

for i in range(len(set_list)-1):
    for j in range(i+1, len(set_list)):
        cnt = len(set_list[i] & set_list[j])
        if cnt >= 2:
            answer += (cnt * (cnt - 1) // 2)

print(answer)
```

---

> **후기**

파이썬 표준 자료형인 `set`클래스에는 `intersection`이라는 메소드를 통해서도 교집합을 구할 수 있지만 `&` 연산자로도 교집합을 구할 수 있는데, 내부적으로 호출되고, 작동하는 방식이 다르다. `a & b` 연산은 내부적으로 `__and__`라는 매직메소드를 호출하게 되는데, 이는 `CPython`에서 `C 코드`로 작성된 로직으로 도달하게 된다. 
당연한 얘기지만 `C 코드`는 파이썬 코드보다 빠르게 작동한다(`pypy`는 구현체가 파이썬이라서 빠른 것이 아니라 고급 최적화 정책을 통해 빠른 것).

반면, `intersection`연산은 `set`클래스의 일반 메소드로, 파라미터의 제네릭이 `iterable`클래스이므로 이를 상속받은 모든 구현체들이 허용된다. 허용되는 파라미터의 범위가 넓은 만큼, 타입 체킹에 오버헤드가 발생할 것이고, 인터프리터가 메소드를 참조하는 등의 오버헤드 또한 추가로 발생한다.

언제나 그렇듯 적절한 `Trade-off`를 생각하여 메소드를 사용해야 하겠지만, `PS`에서는 시간이 중요한 만큼 `stable`한 `intersection`보다는 빠르게 작동하는 `&`를 사용하는 것이 적합할 것이다. (비슷한 이유로 조합을 구현할 때에도, `itertools.combinations`를 사용하는 것 보다 `for문`으로 작성하는 것이 빠르다)

문제 풀이 시간 : 30분 / 실행시간 : `440ms` / 메모리 : `115112KB` / 코드길이 : `467B`

알고리즘 분류 : `자료구조`, `브루트포스`, `해시를 사용한 집합과 맵`

[백준][P2] 1787 문자열의 주기 예측 / (AC)
---
> **문제 설명**
>

[[문제 링크](https://www.acmicpc.net/problem/1787)]

알파벳 소문자들로만 이루어진 문자열을 생각하자. 이런 문자열을 읽어 나가다 보면, 문자열의 주기가 예측되는 순간이 있다. 다음과 같은 문자열을 예로 들어 보자.

<pre>a b a b a b a</pre>

이 문자열을 네 번째 문자까지의 문자열 `a b a b`와, 그 뒤에 남은 `a b a`로 나누어 생각해 볼 수 있다. 이렇게 하면 뒤쪽 문자열은 앞쪽 네 개의 문자 중 세 번째 문자까지가 반복되다가 끝나는 꼴이다.

<pre>a b a b a b a</pre>

또한, 여섯 번째 문자까지의 문자열 `a b a b a b`와, 그 뒤에 남은 `a`로 나누어서 생각할 수도 있다. 이 경우에도 뒤쪽 문자열은 앞쪽 문자열이 반복되다가 끝나는 꼴이다.

즉, 예시된 문자열은 `a b a b`혹은, `a b a b a b`가 반복되는 문자열의 일부라고 예상할 수 있는 것이다. 단, 이러한 추정에서 뒤쪽 문자열이 앞쪽 문자열보다 길면 안 된다. 예를 들어 `a b`는
이 문자열의 주기로 예측하기에는 너무 짧다.

이제는 어떤 문자열 S에 대해, 첫 번째 문자부터, i번째 문자까지로 이루어진 부분 문자열 <span>$S_i$</span>를 생각해 보자. 모든 각각에 대해, 위에 예시된 것처럼 문자열의 주기를 추정할 수 있다.
우리가 관심 있는 것은 이렇게 각각에 <span>$S_i$</span>에 대해 추정할 수 있는 주기 중 가장 긴 것의 길이이다. 이를 <span>$P_i$</span>라고 하자. 예시된 문자열에서 <span>
$P_7$</span>은 4와 6중 최댓값인 6이 된다.

길이가 n인 문자열 S가 주어졌을 때, <span>$P_1 + P_2 + ... + P_n$</span>을 구하는 프로그램을 작성하시오.

---

> **제한사항**
>

**입력**

첫째 줄에 문자열 `S`의 길이 `n`이 주어진다. (1 ≤ n ≤ 1,000,000) 둘째 줄에 문자열 S가 공백 없이 주어진다.

**출력**

첫째 줄에, <span>$P_1 + P_2 + ... + P_n$</span>의 값을 출력한다.


---

> **문제 풀이**

| i | <span>$S_i$</span> | <span>$LPS_i$</span> | <span>$P_i$</span> | 예측 문자열 주기 |
|:---:|:---|:---:|:---:|:---|
| 0 | b         | 0 | 0 | x |
| 1 | ba        | 0 | 0 | x |
| 2 | bab       | 1 | 2 | ba |
| 3 | baba      | 2 | 2 | ba |
| 4 | babab     | 3 | 4 | baba |
| 5 | bababa    | 4 | 4 | baba |
| 6 | bababab   | 5 | 6 | bababa |
| 7 | babababa  | 6 | 6 | bababa |

---

> **코드**
>

```python
import sys

input = sys.stdin.readline

n = int(input())
S = input().rstrip()
pi = [0] * n
answer = 0
lp, rp = 0, 1

while rp < n:
    if S[lp] == S[rp]:
        lp += 1
        pi[rp] = lp
        rp += 1
    else:
        if lp != 0:
            lp = pi[lp - 1]
        else:
            pi[rp] = 0
            rp += 1

for i in range(n):
    if pi[i]:
        if pi[pi[i] - 1]:
            pi[i] = pi[pi[i] - 1]
        answer += i - pi[i] + 1
print(answer)
```

---

> **후기**

구현 원리 자체는 `다익스트라`를 이용한 것이지만, 그냥 `우선순위 큐`를 활용한 `너비 우선 탐색`이라고 봐도 무방하다. 순간이동이 `0`초 만에 가능하다는 점을 고려하기 위해 이렇게 구현했지만, 더 빠른 풀이가
있을 듯...

문제 풀이 시간 : 30분 / 실행시간 : `176ms` / 메모리 : `37044KB` / 코드길이 : `527B`

알고리즘 분류 : `그래프 이론`, `그래프 탐색`, `다익스트라`, `너비 우선 탐색`

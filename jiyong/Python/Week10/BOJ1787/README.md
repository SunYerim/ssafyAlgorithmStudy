[백준][P2] 1787 문자열의 주기 예측 / (AC)
---
> **문제 설명**
>

[[문제 링크](https://www.acmicpc.net/problem/1787)]

알파벳 소문자들로만 이루어진 문자열을 생각하자. 이런 문자열을 읽어 나가다 보면, 문자열의 주기가 예측되는 순간이 있다. 다음과 같은 문자열을 예로 들어 보자.

<pre>a b a b a b a</pre>

이 문자열을 네 번째 문자까지의 문자열 `a b a b`와, 그 뒤에 남은 `a b a`로 나누어 생각해 볼 수 있다. 이렇게 하면 뒤쪽 문자열은 앞쪽 네 개의 문자 중 세 번째 문자까지가 반복되다가 끝나는 꼴이다.

<pre>a b a b a b a</pre>

또한, 여섯 번째 문자까지의 문자열 `a b a b a b`와, 그 뒤에 남은 `a`로 나누어서 생각할 수도 있다. 이 경우에도 뒤쪽 문자열은 앞쪽 문자열이 반복되다가 끝나는 꼴이다.

즉, 예시된 문자열은 `a b a b`혹은, `a b a b a b`가 반복되는 문자열의 일부라고 예상할 수 있는 것이다. 단, 이러한 추정에서 뒤쪽 문자열이 앞쪽 문자열보다 길면 안 된다. 예를 들어 `a b`는
이 문자열의 주기로 예측하기에는 너무 짧다.

이제는 어떤 문자열 S에 대해, 첫 번째 문자부터, i번째 문자까지로 이루어진 부분 문자열 <span>$S_i$</span>를 생각해 보자. 모든 각각에 대해, 위에 예시된 것처럼 문자열의 주기를 추정할 수 있다.
우리가 관심 있는 것은 이렇게 각각에 <span>$S_i$</span>에 대해 추정할 수 있는 주기 중 가장 긴 것의 길이이다. 이를 <span>$P_i$</span>라고 하자. 예시된 문자열에서 <span>
$P_7$</span>은 4와 6중 최댓값인 6이 된다.

길이가 n인 문자열 S가 주어졌을 때, <span>$P_1 + P_2 + ... + P_n$</span>을 구하는 프로그램을 작성하시오.

---

> **제한사항**
>

**입력**

첫째 줄에 문자열 `S`의 길이 `n`이 주어진다. (1 ≤ n ≤ 1,000,000) 둘째 줄에 문자열 S가 공백 없이 주어진다.

**출력**

첫째 줄에, <span>$P_1 + P_2 + ... + P_n$</span>의 값을 출력한다.


---

> **문제 풀이**

먼저, 부분 문자열이 아닌 전체 문자열부터 접근해보자. 문자열 `S`에 대해 추정할 수 있는 최대 길이의 주기는 다음과 같은 간단한 로직으로 찾을 수 있다.

- 문자열의 끝부터 작아지는 방향으로 포인터(`p`) 탐색을 하여, `S[p:len(S)]` 가 `S[:len(S)-p]`와 같아지는 지점을 찾는다. (단, `p`는 `[문자열 길이] / 2` 보다 작아야 한다.)

하지만, 위와 같은 로직을 통해 모든 부분 문자열 <span>$S_i$</span>에 대한 추정 문자열 주기를 구한다면(문자열 비교에 캐싱을 적용하지 않는다면) 시간 복잡도는 `O(N^3)` 꼴과 같다. 입력
문자열의 길이가 `1,000,000`까지 주어지기 때문에 정말 턱 없이 오래 걸릴 것이다.

### 최적화

위의 로직을 조금 다르게 표현한다면, 이렇게 표현할 수 있다. `문자열의 접두사와 접미사가 최소 길이로 같아지는 구간을 찾는다.` 왜냐하면, 이러한 `접미사`를 기준으로 `앞쪽 문자열`은 `접미사`를 추정할 수 있는
문자열이 되기 때문이다. 우리가 알고 싶은 것은 `앞쪽 문자열`의 길이가 최대가 될 때이기에, 반대로 `접미사`의 길이는 최소가 돼야한다.

**그렇다면, 어떻게 최소 길이의 동일한 `접두사`와 `접미사`를 찾을 수 있을까?**

먼저, `KMP` 알고리즘의 `실패 함수(failure function)`를 생각 해보자. `실패 함수`는 `O(N)`만에 모든 부분 문자열에서 각각 LPS(**L**ongest **P**refix which is also **S**uffix: `최대 길이`가 되는 `접두사`이면서 `접미사`)를
찾을 수 있는 알고리즘이다.

**`최소 길이`를 알고 싶다며?**

부분 문자열, LPS의 성질을 활용하면, LPS를 통해 SPS(**S**hortest **P**refix which is also **S**uffix: `최소 길이`가 되는 `접두사`이면서 `접미사`)를 알 수 있다. 아래의 예시를 살펴보자.

어떤 부분 문자열 <span>$S_k$</span>가 `bababab`라고 해보자. 이 부분 문자열의 `LPS`는 `'babab'`가 될 것이다. 그렇다면, `'babab'`의 `LPS`인 `'bab'`
또한 <span>$S_k$</span>의 `접두사`이면서 `접미사`가 될 수 있을 것이다. 왜냐하면, `'bab'`는 <span>$S_k$</span>의 `접두사`의 `접두사`이면서 `접미사`의 `접미사`이기
때문이다. 같은 논리로 `'b'`도 `접두사` 이면서 `접미사`가 될 수 있다. 그리고 `'b'`는 최소 길이의 동일한 `접두사`와 `접미사`, 즉 `SPS`가 된다.

이처럼 `LPS`를 활용하여 `분할 정복`을 통해 `SPS`를 구할 수 있다. 아래의 표와 같이, 어떤 `부분 문자열` <span>$S_i$</span>의 `LPS`의 `LPS`가 존재할 때까지 `recursive`
하게 찾은 `가장 작은 부분 문자열`의 `LPS`가 <span>$S_i$</span>의 `SPS`가 되는 것이다.

`SPS`를 구했다면, `현재 부분 문자열의 길이` - `SPS의 길이`를 통해 <span>$P_i$</span>를 구할 수 있다.

| i | <span>$S_i$</span> | <span>$LPS_i$</span> | <span>$SPS_i$</span> | <span>$P_i$</span> | 추정 문자열 주기 |
|:---:|:---|:---|:---|:---:|:---|
| 0 | b         | - | | 0 | -      |
| 1 | ba        | - | | 0 | -      |
| 2 | bab       | b | b | 2 | ba     |
| 3 | baba      | ba | ba | 2 | ba     |
| 4 | babab     | bab | b | 4 | baba   |
| 5 | bababa    | baba | ba | 4 | baba   |
| 6 | bababab   | babab | b | 6 | bababa |
| 7 | babababa  | bababa | ba | 6 | bababa |

### 구현

프로그램으로 로직을 구현하면 아래와 같다.
<pre>
1. '실패 함수'를 통해 입력 받은 문자열의 LPS(의 길이) 배열을 만든다.
2. LPS 배열을 순회하며 값이 0이 아니라면, 재귀적으로 SPS(의 길이)를 찾는다.
2-1. SPS를 찾았다면, answer에 ([부분 문자열의 길이] - [SPS])만큼 더한다.
3. LPS 배열을 모두 순회했다면, answer를 리턴하고 종료.
</pre>

위처럼 재귀적으로 `SPS`를 찾는 식으로 구현하면 시간복잡도는 `O(N*M)`으로, `M`은 최대 `N`까지 나올 수 있어 `TLE`를 면치 못할 것 같지만, 해당 문제에서는 극단적인 테스트 케이스가 적어서인지 `pypy`로 제출한다면 간당간당하게 통과(`6900ms`)한다.

하지만, `python3`로는 `TLE`가 난다면 `AC`라고 볼 순 없다. 더 최적화를 하는 것은 간단하다. `SPS`를 찾기위해 `LPS`배열을 `재귀적`으로 중복 참조하게 되는데, 이에 `메모이제이션`만 적용해주면 간단하게 해결 가능하다. `LPS` 배열 생성 후 처음부터 읽으면서 `LPS`값을 `SPS`값으로 대체 해주기만 한다면, `Union-find`의 `경로 압축`과 같이 시간복잡도를 크게 낮출 수 있다(`O(N)`).

---

> **코드**
>

```python
import sys

input = sys.stdin.readline

n = int(input())
S = input().rstrip()
pi = [0] * n
answer = 0
lp, rp = 0, 1

while rp < n:
    if S[lp] == S[rp]:
        lp += 1
        pi[rp] = lp
        rp += 1
    else:
        if lp != 0:
            lp = pi[lp - 1]
        else:
            pi[rp] = 0
            rp += 1

for i in range(n):
    if pi[i]:
        if pi[pi[i] - 1]:
            pi[i] = pi[pi[i] - 1]
        answer += i - pi[i] + 1
print(answer)
```

---

> **후기**

백준에서는 `KMP`로 분류되기는 하지만 `문자열`에서 패턴을 검색하는 알고리즘인 `KMP`자체가 사용되는 문제는 아니고, `KMP`의 작동 원리 중 하나인 `문자열 패턴화`를 응용하여 풀 수 있는 문제.

문제 풀이 시간 : 1시간 / 실행시간 : `148ms` / 메모리 : `120620KB` / 코드길이 : `461B`

알고리즘 분류 : `다이나믹 프로그래밍`, `문자열`, `KMP`

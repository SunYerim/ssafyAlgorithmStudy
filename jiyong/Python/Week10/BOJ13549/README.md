[백준][G5] 13549 숨바꼭질 3 / (AC)
---
> **문제 설명**
>

[[문제 링크](https://www.acmicpc.net/problem/13549)]

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

---

> **제한사항**
>

**입력**

첫 번째 줄에 수빈이가 있는 위치 `N`과 동생이 있는 위치 `K`가 주어진다. `N`과 `K`는 정수이다.

**출력**

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.


---

> **문제 풀이**

수직선 상에서의 `최단 경로`를 찾는 문제로, `다익스트라` 알고리즘을 사용하여 문제를 풀었다. 간선의 가중치가 `1` 또는 `0`이기 때문에, `우선 순위 큐`를 통한 탐색을 한다면 처음으로 도착 지점의 최단 거리를 업데이트 하는 시점이, 전체의 최적이 된다는 `Greedy` 전략을 활용하였다.

---

> **코드**
>

```python
import sys
from heapq import heappush, heappop

N, K = map(int, sys.stdin.readline().split())
INF = 100001
dist = [INF] * 100001
dist[N] = 0     # 시작 지점의 최단 거리 = 0

hq = []
heappush(hq, (0, N))    # 0초 시점에 시작 지점에서 출발하는 노드부터 탐색 시작
while hq:
    t, now = heappop(hq)
    if now == K:        # 도착 지점에 도달했다면, 탐색 종료
        break
    for d in (1, -1, 2): 
        if d == 2:      # 2배 위치로 순간 이동하는 경우
            nxt = now * 2   # 위치 *= 2
            time = t        # 시간 = 현재 시점 (0초만에 이동하기 때문에)
        else:           # 인접한 칸으로 이동하는 경우
            nxt = now + d   # 위치 += 변위
            time = t + 1    # 시간 = 현재 시점 + 1
        if 0 <= nxt <= 100000 and dist[nxt] > time: # 이동하고자 하는 곳이 유효한지 / 최단 경로인지
            dist[nxt] = time            # 다익스트라 테이블 업데이트
            heappush(hq, (time, nxt))   # 다음 탐색 지점 큐에 삽입

print(dist[K])
```

---

> **후기**

구현 원리 자체는 `다익스트라`를 이용한 것이지만, 그냥 `우선순위 큐`를 활용한 `너비 우선 탐색`이라고 봐도 무방하다. 순간이동이 `0`초 만에 가능하다는 점을 고려하기 위해 이렇게 구현했지만, 더 빠른 풀이가 있을 듯...  

문제 풀이 시간 : 30분 / 실행시간 : `176ms` / 메모리 : `37044KB` / 코드길이 : `527B`

알고리즘 분류 : `그래프 이론`, `그래프 탐색`, `다익스트라`, `너비 우선 탐색`

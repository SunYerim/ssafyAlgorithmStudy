
[백준][G2] 1167 트리의 지름 / (AC)
---
> **문제 설명**
> 

[[문제 링크](https://www.acmicpc.net/problem/1167)]

트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.


---

> **제한사항**
> 

**입력**

트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.

먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.

**출력**

첫째 줄에 트리의 지름을 출력한다.



---

> **문제 풀이**

해당 문제는 `간선`에 `거리`가 부여된 가중치 트리에서 `정점` 간의 경로 중 가장 긴 길이를 찾는 문제이다.

주어진 입력을 `인접 리스트` 형태의 트리로 전환하고, 이를 이용하여` 깊이 우선 탐색`을 수행하며 최대 길이를 구하면 된다. 하지만 `Brute force`로 모든 정점에서 출발하는 경로를 다 확인한다면 시간복잡도는 `O(n^2)`이 되는데, 정점은 최대 100,000개 이므로 TLE를 피할 수 없다.

**최적화를 어떻게?**

먼저, 문제의 조건을 보면 `거리`는 10,000 이하의 자연수이므로, 특정 정점에서의 `간선`이 2개 이하인 경우, 즉 진행하고자 하는 방향의 경로가 유일한 경우라면 무조건 방문하는 것이 이득이 된다. 또한, 트리는 모든 `정점`이 하나의 트리에 연결되어 있기 때문에, 어떠한 `정점`에서 탐색을 시작해도 트리 전체를 순회하는 경로를 탐색하게 된다. 

정점 `e1`에서 출발하여 `e2 ~ E4`를 지나 `e5` 도착하는 탐색이 `e1`으로 부터 가장 멀리 떨어진 정점으로의 경로라고 가정해보자(이 때, `e2~e4`는 간선을 3개 이상 가질 수 있다). 
트리에서 `깊이 우선 탐색`은 모든 정점을 방문하므로 `e2`에서 `e5` 가는 경로 중 최대 길이의 경로는 `e3 ~ e4`를 지나는 경로와 같다. `e3, e4`도 마찬가지다. 즉, 아무 정점에서나 `깊이 우선 탐색`을 통해 도착하는 최대 길이의 정점이 전체 경우에서 최대 길이가 되는 도착점인 셈이다.

또, 트리는 무향 그래프의 일종이므로 도착점과 시작점을 맞바꿔도 같은 경로를 탐색할 수 있다.

**정리**

1. 아무 정점(풀이에서는 1번 정점)에서 `깊이 우선 탐색`을 통해 최대 길이가 되는 정점과 그 길이를 찾는다.
2. 1에서 찾은 정점에서 다시 한번 `깊이 우선 탐색`을 통해 최대 길이를 찾는다.

위의 간단한 로직만으로 전체의 최적을 찾을 수 있다.



---

> **코드**
> 

```python
import sys


def dfs(n):
    stack = [(n, 0)]
    global max_dist, max_node
    while stack:
        next_node, dist = stack.pop()
        for e, w in graph[next_node]:
            if not visited[e]:
                stack.append((e, dist + w))
                visited[e] = 1
            else:
                if max_dist < dist:
                    max_node = next_node
                    max_dist = dist


N = int(sys.stdin.readline().rstrip())
graph = [[] for _ in range(N + 1)]
max_dist = 0
max_node = None
for _ in range(N):
    input_ = [*map(int, sys.stdin.readline().rstrip().split())]
    s = input_[0]
    it = iter(input_[1:])
    for (e, w) in zip(it, it):
        graph[s].append([e, w])
visited = [0] * (N + 1)
visited[1] = 1
dfs(1)

visited = [0] * (N + 1)
visited[max_node] = 1
dfs(max_node)
print(max_dist)


```

---

> **후기**

TLE를 피하기 위한 전략을 생각해내는 것이 포인트인 문제이다. 그래프와 트리의 특성을 잘 이해하고, 그를 활용할 수 있다면 구현은 어렵지 않게 해낼 수 있다. 만약, `거리`가 음수를 허용했다면 정말 풀기 어려웠을 문제....

문제 풀이 시간 : 2시간 / 실행시간 : `444ms` / 메모리 : `161612KB` / 코드길이 : `822B`

알고리즘 분류 : 트리, 깊이 우선 탐색, 그래프 이론/탐색
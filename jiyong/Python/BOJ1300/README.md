[백준][G1] 1300 K번째 수 / (AC)
---
> **문제 설명**


[[문제 링크](https://www.acmicpc.net/problem/1300)]

세준이는 크기가 `N`×`N`인 배열 `A`를 만들었다. 배열에 들어있는 수 `A[i][j]` = `i`×`j` 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 `N`×`N`이 된다. `B`를 오름차순 정렬했을
때, `B[k]`를 구해보자.

배열 `A`와 `B`의 인덱스는 1부터 시작한다.

---

> **제한사항**
>

**입력**

첫째 줄에 배열의 크기 `N`이 주어진다. `N`은 <span>$10^5$</span>보다 작거나 같은 자연수이다. 둘째 줄에 `k`가 주어진다. `k`는 <span>$min(10^9, N^2)$</span>보다
작거나 같은 자연수이다.

**출력**

`B[k]`를 출력한다.

---

> **문제 풀이**

먼저, 직관적인 풀이 방법은 직접 2차원 `N`×`N` 행렬을 생성하여 `flatten`한 벡터로 변환하여 정렬한 후, `k` 번째 원소를 리턴하는 식으로 구현하는 것이다. 이러한
방식은 `O(N^2 log N^2)` 만큼 소요되는데, `N`이 최대 `100,000`까지 입력되므로 `TLE`를 면할 수 없을 것이다.

**최적화를 어떻게?**

일반적으로 사용되는 정렬 알고리즘은 `O(n log n)`만큼 소요된다. 즉, 이 문제는 실제로 정렬을 수행하지 않고 해답을 찾아야 한다. 먼저 수학적인 사실에 집중해보자. <span>$B_1 ~ B_
{k-1}$</span>까지의 모든 원소는 <span>$B_k$</span>보다 작거나 같다. 이 말은 즉슨, <span>$B_k$</span> 작거나 같은 원소는 <span>$k$</span> 개 이상임을
보장한다.

이러한 수학적 사실을 유념하고 문제를 다시 보자. 우리가 구하고자 하는 것은 <span>$B_k$</span>인데, 만약 <span>$B_k$</span> 값을 임의로 주어준다면, <span>$B_k$</span>
보다 작거나 같은 수를 행렬에서 세는 것은 어려운 일이 아니다.

`N`이 `5`인 행렬 `A` 에서 `B[7]`이 `10`이라고 가정한 경우를 예시로 보자.

|\|1|2|3|4|5| `10`이하인 수의 개수 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **1** | 1 | 2 | 3 | 4 | 5 | 5 |
| **2** | 2 | 4 | 6 | 8 | 10 | 5 |
| **3** | 3 | 6 | 9 | 12 | 15 | 3|
| **4** | 4 | 8 | 12 | 16 | 20 | 2 |
| **5** | 5 | 10 | 15 | 20 | 25 | 2 |

`10`이하인 수의 개수는 총 17개로, 7개보다 크므로 위의 수학적 사실에는 만족하지만, 구하고자 하는 수는 조금 더 7에 인접한 개수를 가지는 `B[k]`일 것이다. 그렇다면 `B[k]`를 조금 낮춰보자.


| \ | 1 | 2 | 3 | 4 | 5 | `5`이하인 수의 개수 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **1** | 1 | 2 | 3 | 4 | 5 | 5 |
| **2** | 2 | 4 | 6 | 8 | 10 | 2 |
| **3** | 3 | 6 | 9 | 12 | 15 | 1|
| **4** | 4 | 8 | 12 | 16 | 20 | 1 |
| **5** | 5 | 10 | 15 | 20 | 25 | 1 |

`5` 이하인 수를 세어보니 총 10개로, 7개에 조금 더 가까워졌다. 조금 더 낮춰보자.

| \ | 1 | 2 | 3 | 4 | 5 | `3`이하인 수의 개수 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **1** | 1 | 2 | 3 | 4 | 5 | 3 |
| **2** | 2 | 4 | 6 | 8 | 10 | 1 |
| **3** | 3 | 6 | 9 | 12 | 15 | 1|
| **4** | 4 | 8 | 12 | 16 | 20 | 0 |
| **5** | 5 | 10 | 15 | 20 | 25 | 0 |

`3` 이하인 수는 총 5개로, 7개에 미치지 못한다. 그렇다면 `B[k]`는 3보다는 크다는 것이다. 마지막으로 `3`과 `5`의 사잇값인 `4`를 확인해보자.

| \ | 1 | 2 | 3 | 4 | 5 | `4`이하인 수의 개수 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **1** | 1 | 2 | 3 | 4 | 5 | 4 |
| **2** | 2 | 4 | 6 | 8 | 10 | 2 |
| **3** | 3 | 6 | 9 | 12 | 15 | 1|
| **4** | 4 | 8 | 12 | 16 | 20 | 1 |
| **5** | 5 | 10 | 15 | 20 | 25 | 0 |

`4` 이하인 수는 총 8개로, 7개 보다는 크면서 7과 가장 인접한 개수를 가진다. 이제 실제 배열 `B`를 보자.

`B` = `[1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6, 8, 8, 9, 10, 10, 12, 12, 15, 15, 16, 20, 20, 25]`

배열 `B`의 `7`번째 원소는 `4`로 위의 과정을 통해 찾아낸 수와 같은 것을 알 수 있다. 이제 일반화를 해보자.
1. 구하고자 하는 `B[k]`를 적당한 수라고 가정해두고, 해당 수보다 작거나 같은 수의 개수를 센다.
2. 1에서 센 수의 개수가 `k`이상이라면 `B[k]`를 더 작은 수로 가정하고, 미만이라면 `B[k]`를 더 큰 수로 가정하여 반복한다.
3. 1~2 과정을 반복하여 찾아낸 최소값이 이 문제의 해답이 된다.

이제 조금 더 구체적으로 프로그래밍으로 구현해보자. 

먼저, 1번 과정에서 적당한 수와 2번 과정에서 바뀌는 수는 `이진 탐색`을 따르게 한다(`O(log n)`번의 탐색만 수행하기 위해).

다음으로 해당 수보다 작거나 같은 수의 개수를 세는 것을 직접 배열을 생성하고 탐색하며 수를 센다면 매우 비효율적일 것이다. 
여기서 유념할 것은 배열 `A`는 일정한 규칙에 따라 `행`과 `열`을 알면 그 값을 바로 알 수 있다는 사실이다. 또한, 각 행의 원소들은 `등차수열`로 이루어지기 때문에, `B[k]`보다 작은 수는 `O(1)`의 연산으로 알 수 있다(`B[k]//(행 번호)`) .

이 두 방식으로 구현한다면, 적당한 수 `B[k]`를 찾고자 하는 탐색 횟수는 `O(log N^2)`, `B[k]`보다 작거나 같은 수는 `O(N)`의 연산을 통해 구할 수 있으므로 `O(N log N^2)`의 시간복잡도로 해결할 수 있는 것이다.


---

> **코드**
>

```python
import sys

input = sys.stdin.readline

N = int(input())
k = int(input())


def bi_search():
    lp, rp = 1, N * N
    answer = rp
    while lp <= rp:
        mid = (lp + rp) // 2
        cnt = 0
        for i in range(1, N + 1):
            if mid // i == 0:
                break
            cnt += min(N, mid // i)
        if cnt < k:
            lp = mid + 1
        else:
            rp = mid - 1
            answer = min(mid, answer)
    return answer


print(bi_search())
```

---

> **후기**

설명은 장황하나, 구현은 그리 어렵지 않다. 시간 복잡도를 획기적으로 줄이기 위해, 명제를 세우고 그를 반영하여 설계하는 것이 중요한 문제.

문제 풀이 시간 : 1시간 / 실행시간 : `212ms` / 메모리 : `109240KB` / 코드길이 : `479B`

알고리즘 분류 : 이진 탐색, 매개변수 탐색

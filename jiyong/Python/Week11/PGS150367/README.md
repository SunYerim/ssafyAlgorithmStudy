[프로그래머스][Lv.3] 150367 표현 가능한 이진트리 / (AC)
---

### 문제 설명


[[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/150367)]

당신은 이진트리를 수로 표현하는 것을 좋아합니다.

이진트리를 수로 표현하는 방법은 다음과 같습니다.

1. 이진수를 저장할 빈 문자열을 생성합니다.
2. 주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다. 루트 노드는 그대로 유지합니다.
3. 만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다. 노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다.
4. 살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다.
5. 문자열에 저장된 이진수를 십진수로 변환합니다.

**이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다.**

다음은 이진트리를 수로 표현하는 예시입니다.

주어진 이진트리는 다음과 같습니다.

<div align="center">
<img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/c3331b5f-2151-4ebd-a20e-8df122709d3e/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.drawio%20%284%29.png" width="400px"/>
</div>

주어진 이진트리에 더미노드를 추가하여 포화 이진트리로 만들면 다음과 같습니다. 더미 노드는 점선으로 표시하였고, 노드 안의 수는 살펴보는 순서를 의미합니다.

<div align="center">
<img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0eb238be-9bfe-479a-bed8-84e1abe63097/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.drawio%20%285%29.png" width="400px"/>
</div>

노드들을 왼쪽에 있는 순서대로 살펴보며 0과 1을 생성한 문자열에 추가하면 `"0111010"`이 됩니다. 이 이진수를 십진수로 변환하면 58입니다.

당신은 수가 주어졌을때, 하나의 이진트리로 해당 수를 표현할 수 있는지 알고 싶습니다.

이진트리로 만들고 싶은 수를 담은 1차원 정수 배열 `numbers`가 주어집니다. `numbers`에 주어진 순서대로 하나의 이진트리로 해당 수를 표현할 수 있다면 1을, 표현할 수 없다면 0을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 1 ≤ numbers의 길이 ≤ 10,000
    - 1 ≤ numbers의 원소 ≤ <span>$10^{15}$</span>

**입출력 예**

| numbers | return |
|:---|:---|
| [7, 42, 5] | [1, 1, 0] |
| [63, 111, 95]	 | [1, 1, 0] |


---

### 문제 풀이

> **문제 해석**

주어진 수를 이진수로 변환하고, `Inorder`의 순서로 각 노드를 `넘버링`한 `특정 깊이(depth)`의 `포화 이진 트리`에서 이진수의 `비트`와 대응되는 노드만 남기고 `비활성화`할 경우에도 트리 구조가 유지되는지를 판별하면 된다. 

<div align="center">
<img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0eb238be-9bfe-479a-bed8-84e1abe63097/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7.drawio%20%285%29.png" width="400px"/>
<div>< 그림 1 ></div>
</div>

그림 1은 `깊이`가 2인 `포화 이진 트리` 에서 숫자 `58`의 이진수 `'0111010'`과 대응되는 노드만 `활성화` 된 상태를 표시한 그림이다. 위 그림은 `0`에 해당하는 노드를 `비활성화` 하여도 여전히 트리 구조를 유지하므로 `58`은 `하나의 이진 트리로 표현 가능한 수`이다.

> **구현**

이제 위의 논리대로 구현하기 위해서 크게 두가지 부분을 생각해주어야 한다.
1. 주어진 수를 이진수로 변환하고, 알맞은 크기의 `포화 이진 트리`로서 해석한다.
2. `비활성화`된 노드를 고려했을 때, 여전히 트리 구조인지 판별한다.

일단 직접 자료구조를 생성하여 구현한다고 생각해보자. 그에 앞서, 시간복잡도를 고려해보아야 한다.

먼저, 주어지는 수의 개수는 `10,000`개 까지 입력되고, 각 수는 최대 <span>$10^{15}$</span>이므로 2진수로 표현하기 위해서는 <span>$\lceil log_2{10^{15} } \rceil$</span>개의 비트(50개)가 필요하고, 이를 `포화 이진 트리`에 담으려면 `63`개의 `노드`가 필요한 셈이다.

아직 `트리 구조` 판별 전략이 명확하지 않지만, `63`개의 노드를 가지는 `10,000`개의 트리정도는 직접 자료구조를 만들어내도 시간상 크게 문제가 없어보이긴 한다. 
하지만, 구현이 복잡한 비선형 자료구조인 `포화 이진 트리`를 만들고, `Inorder`도 구현하기엔 다소 까다로운 면이 있다.

그렇다면 이제 `포화 이진 트리`와 `Inorder`의 특성을 생각해보자. 
- `포화 이진 트리`는 `루트 노드`를 기준으로 `왼쪽 서브트리`와 `오른쪽 서브트리`의 크기가 동일하다. 이는 리프가 아닌 모든 `서브트리`에서도 동일하다.
- `Inorder`는 `분할 정복`을 통해 `왼쪽 서브트리` - `루트 노드` - `오른쪽 서브트리`의 순으로 탐색하는 탐색법이다.

**감이 오지 않는가?**

우리는 주어진 수를 이진수로 변환하여 `비트열`을 알 수 있다. 그 비트열을 `Inorder` 넘버링에 따라 `포화 이진 트리`로서 해석하려고 한다.  
`포화 이진 트리`와 `Inorder`의 특성에 의해 `루트 노드`는 `비트열`의 `len(bit)//2`번째 비트와 대응될 것이다.
또한, 해당 비트를 기준으로 `왼쪽 부분 비트열`과 `오른쪽 부분 비트열`은 각각 `포화 이진 트리`의 `왼쪽 서브트리`와 `오른쪽 서브트리`에 해당한다.
 
이제 트리 구조를 판별하는 부분을 생각해보자. `트리`의 정의는 `'모든 노드가 회로가 없이 연결된 무향 그래프'`이다. 즉, 모든 `노드`가 연결되어 있어야 한다. 이 문제에서는 `포화 이진 트리`에서 `활성화`된 모든 노드가 연결되어 있어야 하므로, 모든 `활성화 노드`의 부모 노드도 `활성화 노드`여야 한다.
  
  이를 명제로 바꾸면, `'어떤 노드의 서브트리 중 하나라도 활성화(비트가 1)된 상태의 노드가 있다면, 해당 노드는 활성 상태(1)여야 한다'`가 된다. 이를 좀 더 직관적으로 바꾸면, `'어떤 노드가 '0'이면, 모든 서브트리의 노드들은 '0'이어야 한다'(명제의 대우)`가 된다.

명확한 명제를 얻었으므로, `비트열`에서 `분할 정복`을 통해 `루트 노드`와 `서브트리`를 구하고 위의 명제를 만족하는지 재귀적으로 판별한다면, 트리 구조를 판별할 수 있을 것이다.
  
이제 코드로 구현해보자.
  
<pre>
1. 주어진 수를 '비트열'로 변환하고, '포화 이진 트리'에 알맞게 비트열의 왼쪽에 '0'을 padding 한다. (주어진 비트열 길이보다 크거나 같은 2^n - 1개)
2. '비트열'을 '왼쪽 서브트리', '루트 노드', '오른쪽 서브트리'로 나눈다.
3. '루트 노드'가 '0' 이라면 '서브트리' 중 '1'이 존재하는지 -> return False if '1' in sub_trees else True
4. 아니라면 모든 '서브트리'에 대해 '분할 정복' 수행
</pre>

---

### 코드


```python
from math import log2, ceil


def solution(numbers):
    answer = []
    for num in numbers:
        binary = to_binary(num)
        answer.append(1 if can_exp(binary) else 0)
    return answer


def to_binary(n: int):
    bi = list(bin(n)[2:])
    l = 2 ** ceil(log2(len(bi))) - 1
    if len(bi) < l:
        bi = ["0"] * (l - len(bi)) + bi
    elif len(bi) > l:
        bi = ["0"] * (((l + 1) * 2 - 1) - len(bi)) + bi
    return bi


def can_exp(b: str):
    if len(b) == 1:
        return True
    l, c, r = b[:len(b) // 2], b[len(b) // 2], b[len(b) // 2 + 1:]
    if c == '0':
        if l.count('1') or r.count('1'):
            return False
        else:
            return True
    else:
        return all((can_exp(l), can_exp(r)))


# test driver
if __name__ == '__main__':
    print(solution([7, 42, 5]))
    # output : [1, 1, 0]
```

---

### 후기

장황하게 풀이를 적었으나 설명할 부분이 많은 것이지, 그리 어렵지는 않은 문제. 카카오 기출 문제인 것을 감안하면 아주 쉬운 편에 속한다고 생각한다.

문제 풀이 시간 : 30분

알고리즘 분류 : `이진 트리 탐색(Inorder)`, `분할 정복`, `그래프 이론`

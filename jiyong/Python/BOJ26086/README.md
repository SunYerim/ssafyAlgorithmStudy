
[백준][G3] 26086 어려운 스케줄링 / (AC)
---
> **문제 설명**
> 

[[문제 링크](https://www.acmicpc.net/problem/26086)]

지환이는 업무에 치여 산다. 하루에도 몇 건인지도 모를 정도로 많은 업무가 들어온다.

각 업무는 양의 정수로 표현되는 고유번호 $p_i$ ($1 \leq p_i \leq N$)를 가지고 있으며, 고유번호는 모두 다르다.

아, 일이 또 추가되었다. 참다못한 지환이는 스케줄링을 하기 위한 기계 ‘지환봇 스케줄러’를 만들었지만, 그마저도 제대로 만들지는 못한 것 같다. '지환봇 스케줄러'는 기본적으로는 스택(stack) 구조, 즉 제일 나중에 들어간 업무가 제일 먼저 처리되는(LIFO, Last in First out) 특성을 가지고 있다.

기본적인 특성과 더불어, '지환봇 스케줄러'에게 할 수 있는 명령은 다음과 같다.

- $0\ p$: 고유번호가 
$p$인 업무를 스케줄러에 추가한다. 특별히 다른 명령이 없는 한, 새로 추가된 일은 스케줄러 상의 맨 앞에 추가된다. 즉, 고유번호 값에 상관없이 스케줄러에서 가장 먼저 처리되어야 하는 업무가 된다.
- `$1$: 스케줄러에 들어있는 업무를 고유번호 값 기준으로 오름차순으로 정렬한다. 이 결과, 고유번호 값이 낮은 업무일수록 스케줄러의 앞에 배치된다.
- $2$: 스케줄러에 있는 업무 처리 순서를 뒤집는다. 즉, 스케줄러에 들어가 있는 업무들의 처리 순서가 반대가 된다.

'지환봇 스케줄러'에 필요 없어 보이는 기능이 있는 것 같지만, 지환이는 이전보다 효과적인 업무처리를 기대할 수 있을 것 같다. 주어진 
$Q$개의 명령을 순서대로 처리한 후, 
$k$번째로 처리해야 하는 업무의 고유번호는 무엇일까?

---

> **제한사항**
> 

**입력**

첫째 줄에 업무의 고유번호의 범위 제한 
$N$과 명령 횟수 
$Q$, 
$k$가 주어진다. (
$1\leq N,Q \leq 100\,000,\ 1\leq k \leq$ '0번 명령의 등장 횟수')

둘째 줄부터 
$Q$개 줄에 걸쳐 명령에 대한 정보가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

**출력**

모든 명령을 순서대로 적용한 후, 
$k$번째로 처리하게 될 업무의 고유번호를 출력한다.

---

> **문제 풀이**

명령은 총 세가지 종류로 `push`, `reverse`, `sort`가 있는데, 이는 각각 `O(1)`, `O(n)`, `O(n log n)`의 시간복잡도를 가진다. 명령을 입력 받을 때마다 처리를 한다면, TLE를 피할 수 없을 것이다. 

지문을 자세히 보면,  모든 명령(쿼리)를 적용한 후의 결과만을 요구하니까, 명령이 실행되는 중간 과정은 중요치않다. 즉, 명령을 모두 입력받은 뒤 상쇄되는 명령은 제외하고 일괄처리 하는 전형적인 
`오프라인 쿼리` 유형의 문제이다.

만약, `1`번 명령이 실행된다면, 이전의 명령이 어떻든 결과는 항상 정렬된 스케줄러가 될 것이다. 이를 유념하며 알고리즘을 작성하면 된다.

1. `0`번 명령: 스케줄러에 새로운 스케줄을 추가한다.
2. `1`번 명령: 쿼리 덱을 비우고, 쿼리 스택에 `(1, 현재 스케줄러 길이)`를 추가한다.
3. `2`번 명령: 쿼리 덱에 `(2, 현재 스케줄러 길이)`를 추가한다.
4. 모든 명령에 대하여 1~3에 따라 수행한 후, 쿼리 덱을 처음부터 읽으며 명령을 실행한다.

---

> **코드**
> 

```python
import sys

N, Q, k = map(int, sys.stdin.readline().rstrip().split())

tasks = []
queries = []

for _ in range(Q):
    query = sys.stdin.readline().rstrip()
    if query[0] == '0':
        tasks.append(int(query[2:]))
    elif query[0] == '1':
        queries.clear()
        queries.append([1, len(tasks)])
    else:
        queries.append([2, len(tasks)])

for query in queries:
    q, l = query
    if q == 1:
        tasks = sorted(tasks[:l], reverse=True) + tasks[l:]
    else:
        tasks = tasks[:l][::-1] + tasks[l:]

print(tasks[-k])
```

---

> **후기**

쿼리들을 저장하는 자료구조를 `덱(Deque)`이라고 명시하였으나(맨 앞과 뒤에서 입출력이 일어나므로), 이는 추상적인 개념으로 실제로는 구현부에서 `순차 리스트`를 이용하였다.



문제 풀이 시간 : 20분 / 실행시간 : `148ms` / 메모리 : `118184KB` / 코드길이 : `545B`

알고리즘 분류 : 덱, 오프라인 쿼리, 정렬